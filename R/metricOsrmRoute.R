#' @name metricOsrmRoute
#'
#' @title Calculer le temps de trajet et la distance entre deux points ainsi que la geometrie du trace
#'
#' @description La fonction metricOsrmRoute permet de calculer le temps de trajet et la distance
#' entre deux points seulement et de récupérer le tracé de la route empruntée.
#'
#' La fonction permet également d’ajouter des points intermédiaires entre la source (src) et la destination (dst) pour former un itinéraire.
#'
#' @param src vecteur numérique de longueur 2 (lon/lat) ou 3 (id/lon/lat), data.frame d'une ligne (colonnes lon/lat ou id/on/lat),
#' objet sf d'une ligne ou sp d'une entité (SpatialPointsDataFrame ou SpatialPolygonsDataFrame).
#' @param dst vecteur numérique de longueur 2 (lon/lat) ou 3 (id/lon/lat), data.frame d'une ligne (colonnes lon/lat ou id/on/lat),
#' objet sf d'une ligne ou sp d'une entité (SpatialPointsDataFrame ou SpatialPolygonsDataFrame).
#' @param loc data.frame (colonnes lon/lat ou id/on/lat), objet sf ou sp (SpatialPointsDataFrame ou SpatialPolygonsDataFrame) précisant les points
#' intermédiaires du trajet.
#' @param overview texte. "simplified" (par défaut), "full" ou NULL. Renvoie une géométrie simplifiée ou détaillée du tracé ou seulement le temps et la distance si NULL.
#' @param returnclass texte. "sf", "sp" ou NULL (par défaut). Renvoie un objet sf (LINESTRING), sp (SpatialLineDataFrame) ou un data.frame de coordonnées si NULL.
#' @param exclude texte. Permet aux trajets d'éviter les autoroutes (“motorway”), les péages (“toll”) ou les ferries (“ferry”). Par défaut NULL.
#'
#' @return Un data.frame, un objet spatial sf (LINESTRING) ou sp (SpatialLineDataFrame).
#'
#' @details Le choix de overview = "full" augmente le temps de calcul puisqu’il permet de renvoyer une géométrie
#' détaillée du tracé avec plus de coordonnées. Ce choix est toutefois obligatoire si l’on veut représenter
#' ensuite des routes proportionnelles à partir de la fonction routesProportionnelles.
#'
#' Pour cette usage, il est aussi conseillé de spécifier le paramètre returnclass = NULL pour diminuer le temps
#' de calcul. Les coordonnées des tronçons de route seront alors retournées sans la géométrie.
#'
#' L'argument loc peut être utilisé à la place de src et dst pour forcer le trajet à emprunter des points intermédiaires créant ainsi un itinéraire.
#' La première ligne de loc est le point de départ, la dernière ligne le point d’arrivée.
#' Ce dernier peut être identique au point de départ pour former une boucle de trajet.
#'
#' @importFrom sf st_sf st_as_sf st_as_sfc st_crs st_geometry st_centroid st_transform st_coordinates st_collection_extract
#' @importFrom RJSONIO fromJSON
#' @importFrom methods as
#' @importFrom gepaf decodePolyline
#' @export
#'
#' @examples
#' # Specification d'un serveur osrm obligatoire pour executer les exemples
#' options(osrm.server = "https://metric-osrm-backend.lab.sspcloud.fr/")
#'
#' # Specification du profil
#' options(osrm.profile = "driving")
#'
#' # Calcul d'un trace de route simplifie en data.frame.
#' dt_route_s <- metricOsrmRoute(src = data.frame(lon = 4.92,
#'                                                lat = 46.15),
#'                               dst = data.frame(lon = 4.72,
#'                                                lat = 45.92),
#'                               overview = "simplified")
#'
#' # Calcul d'un trace de route detaille en data.frame.
#' dt_route_f <- metricOsrmRoute(src = data.frame(lon = 4.92,
#'                                                lat = 46.15),
#'                               dst = data.frame(lon = 4.72,
#'                                                lat = 45.92),
#'                               overview = "full")
#'
#' # Calcul d'un trace de route simplifie en objet sf.
#' sf_route_s <- metricOsrmRoute(src = data.frame(lon = 4.92,
#'                                                lat = 46.15),
#'                               dst = data.frame(lon = 4.72,
#'                                                lat = 45.92),
#'                               overview = "simplified",
#'                               returnclass = "sf")
#'
#' plot(sf::st_geometry(sf_route_s), col = "red")
#'
#' # Calcul d'un trace de route detaille en objet sf.
#' sf_route_f <- metricOsrmRoute(src = data.frame(lon = 4.92,
#'                                                lat = 46.15),
#'                               dst = data.frame(lon = 4.72,
#'                                                lat = 45.92),
#'                               overview = "full",
#'                               returnclass = "sf")
#'
#' plot(sf::st_geometry(sf_route_f), col = "blue", add = TRUE)
#'
#' # Calcul d'une boucle d'itineraire en trace simplifie et objet sf.
#' sf_route_s_boucle <- metricOsrmRoute(loc = data.frame(
#'                                              lon = c(4.92,4.83,4.72,4.89,4.92),
#'                                              lat = c(46.15,45.99,45.92,46.12,46.15)),
#'                                      overview = "simplified",
#'                                      returnclass = "sf")
#'
#' # boucle
#' plot(sf::st_geometry(sf_route_s_boucle))
#' # Points de depart et d'arrivee
#' plot(sf::st_point(c(4.92, 46.15)), col = "red", add = TRUE)
#' # Point intermediaire 1
#' plot(sf::st_point(c(4.83, 45.99)), col = "blue", add = TRUE)
#' # Point intermediaire 2
#' plot(sf::st_point(c(4.72, 45.92)), col = "green", add = TRUE)
#' # Point intermediaire 3
#' plot(sf::st_point(c(4.89, 46.12)), col = "orange", add = TRUE)
#'
metricOsrmRoute <-
function (src, dst, loc, overview = "simplified", returnclass = NULL, exclude = NULL)
{
  exclude_str <- ""
  if (missing(loc)) {
    src <- input_route(x = src, id = "src", single = TRUE)
    dst <- input_route(x = dst, id = "dst", single = TRUE)
    id1 <- src$id
    id2 <- dst$id
    if (!is.null(exclude)) {
      exclude <- paste(exclude, sep = "", collapse = ",")
      exclude_str <- paste("&exclude=", exclude, sep = "")
    }
    req <- paste(getOption("osrm.server"), "route/v1/",
                 getOption("osrm.profile"), "/", src$lon, ",", src$lat,
                 ";", dst$lon, ",", dst$lat, "?alternatives=false&geometries=polyline&steps=false&overview=",
                 tolower(overview), exclude_str, sep = "")
  }else{
    loc <- input_route(x = loc, single = FALSE)
    id1 <- loc$id1
    id2 <- loc$id2
    if (!is.null(exclude)) {
      exclude_str <- paste("&exclude=", exclude, sep = "")
    }
    req <- paste(getOption("osrm.server"), "route/v1/",
                 getOption("osrm.profile"), "/", paste0(apply(data.frame(loc$lon,
                                                                         loc$lat), MARGIN = 1, FUN = paste0, collapse = ","),
                                                        collapse = ";"), "?alternatives=false&geometries=polyline&steps=false&overview=",
                 tolower(overview), exclude_str, sep = "")
  }

  resRaw <- utils::URLencode(req)

  res <- RJSONIO::fromJSON(resRaw)

  if (overview == FALSE) {
    resultat <- c(duree = round(res$routes[[1]]$duration/60,2),
                  distance = round(res$routes[[1]]$distance/1000,3))
  }else{

    geodf <- gepaf::decodePolyline(res$routes[[1]]$geometry)[,c(2, 1)]
    resultat <- geodf

    if (!is.null(returnclass)) {
      rcoords <- paste0(geodf$lon, " ", geodf$lat, collapse = ", ")
      rgeom <- (sf::st_as_sfc(paste0("LINESTRING(", rcoords,
                                     ")")))
      rosf <- sf::st_sf(src = id1, dst = id2, duree = round(res$routes[[1]]$duration/60,2),
                        distance = round(res$routes[[1]]$distance/1000,3), geometry = rgeom,
                        crs = 4326, row.names = paste(id1, id2, sep = "_"), stringsAsFactors = FALSE)
      if (returnclass == "sp") {
        rosf <- methods::as(rosf, "Spatial")
      }

      resultat <- rosf
    }else
    {
      resultat <- data.frame(src = id1, dst = id2, duree = round(res$routes[[1]]$duration/60,2),
                             distance = round(res$routes[[1]]$distance/1000,3), lon = resultat$lon, lat = resultat$lat,
                             stringsAsFactors = FALSE)
    }
  }

  return(resultat)
}
